
ddl command:data definiation language 
define and modify the databaese structure of table or schema
ddl commandss::
create
alter 
drop
truncate
rename
 

desc <table_name>
create table <tablename>(column1 datatype,column1 datatype);
drop table <tablename>
alter table <tablename> add <columnname> <datatype>

alter table <tablename> drop <columnname>
modifing column::
alter table <tablename> modify <columnname> <datatype> default <value>
default value::
alter table <tablename> alter <columnname> default 'defaultvalue' ;

rename change tablename::
alter table <tablenamn> rename to <newtablename>;

truncate::
:truncate table student;(drop table columns ddl commands it cannot be rooled back table structre rename same but columns are deleted)
:delete from student;(it is dml command)

in drop student( table completly remove )


DML commands::(data manipulation language ) act row of a table
insert 
update
delete

insert::
insert into <tablename>(column1 ,column ... ) values (value1,value...),(value1,value...);

update::
update <tablename> set <columnname>=value where <columnname>=value;

update student set age=10,name='dd' where sid=4;

delete::
delete from <tablename> where <columnanme>=value;
delete from <tablename> (whole table rows delete )


date function::
current date::
curdate();

MONTHS DIFF
timestampdiff(month,'YYYY-MM-DD','YYYY-MM-DD')

timestampdiff(day,'YYYY-MM-DD','YYYY-MM-DD')

select ename,salary,timestamdiff(year,hiredate,curdate()) as yearworked from employees;


::salary diff and increment salary of those employees whose hire date greater then 1 years::
select ename,hiredate,timestampdiff(year,hiredate,curdate()) as yearworked,
if(timestampdiff(year,hiredate,curdate())>1,salary+salary*0.1,salary) as newsalary from employees;

QUARTER function::
select quarter(curdate());


case :::
select ename ,hiredate ,case
	when quarter(hiredate) 1 then 'firstquarter'
	when quarter(hiredate) 2 then 'secquarter'
	when quarter(hiredate) 3 then 'thrquarter'
	when quarter(hiredate) 4 then 'fourquarter'
	end as hireQuarter
from employees;


current dayname::
dayname(curdate()):

case example::
select case(dayname(curdate()))
	when 'sunday' then 'weekend'
	when 'saturday' then 'weekend'
	else 'weekday'
end as dow;

::current months::
select extract(month from curdate());


str_to_date function::
select str_to_date('11-12-17','%m-%d-%y');
op:: 2017-11-12 

select clauses::return row by row
select * from <tablename>;
select columnname,... from <tablename>;
select a from <tablename>  it goes to each row then retreive

where clause::
select ename,salary,salary*12 as 'yearsal' from employees;

select used by row by row
where clause use for filtering data
select ename,salary,salary*12 as 'yearsal' from employees where deptid=20 and salary>12000;

select ename,salary,salary*12 as 'yearsal' from employees where (deptid=20 or deptid=10) and salary>12000;

clasuse in sql::
in, between and likes::
in == exact matching
between == range matching
like == pattern matching

select ename ,salary from employees where designation='abc' or designation='xyz';

in clause
select ename ,salary from employees where designation in('abc','xyz') ;

select ename ,salary from employees where deptid=10 or deptid=20;
select ename ,salary from employees where deptid in(10,20) and salary>20000;

between::>= and <=
select ename from employees where salary>=20000 and salary<=30000;
select ename from employees where salary between 20000 and 30000;

select ename from employees where salary between 20000 and 30000 and deptid=10;

select ename from employees where salary between 20000 and 30000 and deptid in(10);


Like::%(match any string) _(single character matching)::
select ename from employees where ename like 'n%'; start with n
select ename from employees where ename like '%n'; end with n

select ename from employees where ename like '___'; contain 3 char

select ename ,designation from employees where desgination in('mangaer','developer') and ename like 'n%';


handling null values::
null::undertermine value
0::it is determine value

null value +any arthematic operation is undertermine value
null value cannt be equate:
select ename from employees where commission =null

so we are using is clause:
select ename from employees where commission is null
select ename from employees where commission is not null


orderby clause::by default asc order
select ename ,salary from employees order by salary;

select ename ,salary from employees order by salary desc;

first sort by deptid then if any dept id is repeated then they sort on bais of salary
select ename ,salary from employees order by deptid, salary;
like 
depid salary
30 3000
30 4000
20 2000
20 3000

used order by with conjunctio of where clause
select ename ,salary from employees where deptid=20 order by salary desc;

limit key word::fetch me firsts three records
select eid from employees limit 3;

indexing limits::
select eid from employees limit 1,3; getting 3 rows

higehest salary::
select eid from employees order by salary desc limit 1;

second highest salary
select eid from employees order by salary desc limit 1,1; //indexing 1 and 1

case statements::
case <expression> 
when <case exmpression1> then command
when <case exmpression2> then command
else commands
end

find number is even or odd

set @number=10;
select case(@number%2)
when 0 then 'even'
when 1 then 'odd'
end as ecode

for aliasing using as

conditionally increment sallary on basis of dept manage increase by 2000 if developer incr by 1000 else remain same

select ename ,salary ,case(designation)
when 'manger' then salary +2000
when 'developer' then salary +1000
else salary 
end as netsalary 
from employees;

adding prefix mr,mrs on the basis of gender
select ename, case(gender)
when 'm' then concat('mr',ename)
when 'F' then concat('mrs',ename)
else ename end as name
from employees;

string function::
length function
select length('abc');
op :3

upper::
select upper('abc');

substring::
select substring('nikhil',2,4)
op::ikhi (from second pos we extract 4 character)

instr() ::index pos find out
select instr('nikhil' ,'i')
first occurance of i
op::2

concat('','') concat both of string and 2 level of nesting is perform

for adding first and last name with space seprator::
select first,last,concat(first,concat(' ',last)) from employees;

ltrim()::remove left side  trailling spaces
select ltrim('  abc');
op abc

repeat ::repetion of particular value
like repeat('*',5)::*****

replace('amit','a','v'):replace a with v
op:::vmit





new
================================
select * from employee where salary=6000;
then it go through all data and 

idexes on commision column 

create index index3 on employees (commission);

explain select ename from employees where commission =50000;


cluster indexes;
secondary index allocation is differently


indexes stored values in sorted order by default ascending order;;


searching containt in books from indexs


genral cluster indexes;;
storing data of the table into insertion order::


cluster and secondary indexes::
a clustered index determines the physical order of data in a table it is analogus to a telephone directory,it doesnot required any addition disk space.

a table can have only one cluster index .

primary key constraint creates a clustered index automatically

secondary index is same as index of text book where data stored in one place and index into another,index is a pointer of data ,

in secondary index data storage in asceding order and a single table has more then one secondary indexes.

select table_id from information_schema.innodb_sys_talbes wher name='test/emp'

primary key create automatically cluster index into table ;	


disadvantages::
insertion , deletion and updataion is create more complexcity into tables.


stored procedures:::
it is segement of decalarative statement stored inside database catalogs

it increase performance ,reduce network traffic,provide code resusality and security..

stored in pass in complile format inside database;

create procedure <procedure name>(parm_list)
begin
  varialble declaration;
  perform some operation
end

paramert passed inside store procedure::
3 fromat::
IN, OUT and INOUT;


set @a=2;

create  procedure pp5(IN a integer)
begin 
set a=10;
end &

o/p::2
create  procedure pp5(OUT a integer)
begin 
set a=10;
end &

o/p::10

create  procedure pp5(INOUT a integer)
begin 
set a=10;
end &

o/p::

call pp5(@a);
op
 
delimiter &

set @a=4;
create procedure pp1(IN a integer)
begin 
set a=a+10;
end &


number is odd or even ::
delimiter &

create procedure odd_even(IN num integer)
begin 
if num%2 =0 then
select 'the number is even';
else 
select 'number is odd';
end if;
end &

loops::
while loops::


delimiter &
create procedure id_prime(IN a integer)
begin 
declare count integer;
declare num integer;
set num=2;
set count=0;

while num<=a/2 do
if a%num=0 then
set count=count+1;
end if;
set num=num+1;
end while
if count=0 then
select 'the number is prime';
else 
select 'the number is composite';
end if
end &


